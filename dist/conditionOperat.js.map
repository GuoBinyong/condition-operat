{"version":3,"sources":["webpack://conditionOperat/webpack/universalModuleDefinition","webpack://conditionOperat/webpack/bootstrap","webpack://conditionOperat/./src/conditionOperat.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","isBoolCondition","condExp","isObject","isPromCondition","Promise","isConditionSet","Array","isArray","notOperat","target","notSequ","reduce","res","not","flatFunCondition","thisValue","args","isFunCondition","funRes","apply","isNotExpression","conditionOperat","condExpress","condSet","notOper","b","proCondArr","condSetArr","rel","orRes","some","push","length","cond","allSettled","then","proCondArrResArr","proCondResArr","map","proRes","status","andRes","every","exprOrOpts","opts","expr","argArr","rest","finalArgArr","argItem","undefined","shift"],"mappings":"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","file":"conditionOperat.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"conditionOperat\"] = factory();\n\telse\n\t\troot[\"conditionOperat\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * 非运算表达式\n */\ninterface NotExpression {\n  /**\n   * 对原来的值取反\n   */\n  not?:boolean\n}\n\n\n/**\n * NotExpression 的类型守卫\n * @param condExp : CondExpression 表达式\n */\nfunction isNotExpression(condExp:CondExpression<any,any>): condExp is NotExpression {\n  return isObject(condExp)\n}\n\n\n\n\n\n/**\n * 布尔条件\n * 代表那些可直接被当作布尔值来计算的 真假 和 假值；\n */\ntype BoolCondition = boolean | number | string | symbol | undefined | null\n\n\n\n/**\n * BoolCondition 的类型守卫\n * @param condExp : CondExpression 表达式\n */\nfunction isBoolCondition(condExp:CondExpression<any,any>): condExp is BoolCondition {\n  return !isObject(condExp)\n}\n\n\n/**\n * 异步条件\n * 根据决议的值反复地进行条件运算，直到计算到得到 布尔结果 为止；\n */\ninterface PromCondition<ThisValue,Args> extends Promise<CondExpression<ThisValue,Args>>,NotExpression {}\n\n\n\n/**\n * PromCondition 的类型守卫\n * @param condExp : CondExpression 表达式\n */\nfunction isPromCondition<ThisValue,Args>(condExp:CondExpression<ThisValue,Args>): condExp is PromCondition<ThisValue,Args> {\n  return condExp instanceof Promise\n}\n\n\n\n/**\n * 函数条件\n * 带有逻辑的函数，会对其返回值反复地进行条件运算，直到计算到得到 布尔结果 为止；\n */\ninterface FunCondition<ThisValue,Args> extends NotExpression {\n  (this:ThisValue,...args:Args extends any[] ? Args : []):CondExpression<any,any>;\n}\n\n\n/**\n * FunCondition 的类型守卫\n * @param condExp : CondExpression 表达式\n */\nfunction isFunCondition<ThisValue,Args extends any[]>(condExp:CondExpression<ThisValue,Args>): condExp is FunCondition<ThisValue,Args> {\n  return typeof condExp === \"function\"\n}\n\n\n\n\n/**\n * 条件的类型\n * 条件是用来表达 真 或 假 的基本运算单元；\n */\ntype Condition<ThisValue,Args> = BoolCondition | FunCondition<ThisValue,Args> | PromCondition<ThisValue,Args> | NotExpression\n\n/**\n * 基础条件的类型；\n * 该类型的条件不需要经过复杂的运算，可根据 not 属性(如果有)，直接将其自身的值作为布尔值来来运算\n */\ntype BaseCondition = Exclude<Condition<any,any>, FunCondition<any,any> | PromCondition<any,any>>\n\n\n/**\n * 关系类型\n */\ntype Relationship = \"and\" | \"or\"\n\n/**\n * 运算结果的类型\n */\ntype OperatedResult = boolean | Promise<boolean>\n\n/**\n * 条件集\n * 条件集 ConditionSet 是用来表达 多个条件表达式 相与 或者 相或 关系的一种表达式；它包含多个条件表达式，并携带有关系信息（与、或）；\n */\ninterface ConditionSet<ThisValue,Args>  extends Array<CondExpression<ThisValue,Args>>,NotExpression{\n  /**\n   * 各个条件表达式之间的关系；\n   * 默认值：\"and\"\n   */\n  rel?:Relationship;\n}\n\n\n/**\n * ConditionSet 的类型守卫\n * @param condExp : CondExpression 表达式\n */\nfunction isConditionSet<ThisValue,Args>(condExp:CondExpression<ThisValue,Args>): condExp is ConditionSet<ThisValue,Args> {\n  return Array.isArray(condExp)\n}\n\n\n\n\n/**\n * 条件表达式\n * 条件集 ConditionSet 和 条件 Condition 统称为 条件表达式\n */\ntype CondExpression<ThisValue,Args> = ConditionSet<ThisValue,Args> | Condition<ThisValue,Args>\n\n\n\n\n\n\n\n\n\n/**\n * 非值的类型\n */\ntype NotValue = NotExpression[\"not\"]\n\n/**\n * 非值的序列\n */\ntype NotSequence = NotValue[]\n\n\n/**\n * 对 target 做一系列连续的 非操作，\n * @param target : any    操作的目标，会直接将其作为布尔值来对待\n * @param notSequ : NotSequence    指示非操作序列的数组\n * @return boolean     非操作后的结果\n */\nfunction notOperat(target:any,notSequ:NotSequence):boolean {\n  return !!(notSequ.reduce(function (res,not) {\n    return not ? !res : res;\n  },target))\n}\n\n\n\n\n/**\n * 扁平化 函数条件\n * @param condExp : CondExpression   条件表达式；如果 condExp 不是函数条件，则不作处理 返回 condExp 自身\n * @param thisValue ?:  any   可选；函数条件的 this 的值\n * @param args ?:any[]      可选；函数条件的 参数\n *\n * 函数条件可能还会返回函数条件，返回的函数条件可能还会返回函数条件，可以无休止地这样延续下去；\n * 本方法的作用就是对函数条件进行运算，直到返回的不是函数条件为止\n */\nfunction flatFunCondition<ThisValue,Args>(condExp: CondExpression<ThisValue,Args>,thisValue?:ThisValue, args?:Args): Exclude<CondExpression<ThisValue,Args>, FunCondition<ThisValue,Args>> {\n  if (isFunCondition(condExp)) {\n    let notSequ = [condExp.not]\n    // @ts-ignore\n    let funRes = condExp.apply(thisValue,args)\n\n    if (isNotExpression(funRes)) {\n      funRes.not = notOperat(funRes.not, notSequ)\n      return flatFunCondition(funRes,thisValue,args)\n    }\n\n    return notOperat(funRes, notSequ)\n  }\n\n  return condExp\n}\n\n\n/**\n * 判断目标是否是对象类型\n * @param target : any   目标对象\n *\n * 仅通过 target instanceof Object 判断是不行的，因为 对于 Object.create(null) 创建的对象 通过 ` Object.create(null) instanceof Object ` 来判断 返回的是 false\n * 即：通过 Object.create(null) 创建的对象是不被 instanceof  认为是继续于 Object 的\n */\nfunction isObject(target:any):boolean {\nreturn target instanceof Object || typeof target === \"object\"\n}\n\n\n\ninterface conditionOperat<ThisValue,Args> {\n  create(expr:CondExpression<ThisValue,Args>): (thisValue?:any, args?:any[])=>OperatedResult;\n  create(options:CreateOptions<ThisValue,Args>): (...rest: any[])=>OperatedResult;\n}\n\n\n\n\n/**\n * 条件运算\n * 对一系列条件进行逻辑运算；\n * @param condExpress : CondExpression   条件表达式\n * @param thisValue ？: any   设置条件表达式中 函数条件 的 this 的值\n * @param args ？: any[]   设置条件表达式中 函数条件 的 参数序列； 即该参数是个数组，里面包含传递给 条件函数 的参数\n *\n * @return OperatedResult 返回布尔类型 或者 返回布尔类型的Promise类型 的值\n * \n * 注意：\n * thisValue 和 args 会被应用到所有的 函数条件，包括那些 运算过程 中产生的函数条件，比如：函数条件返回的函数条件、异步条件决议时传递出的 函数条件\n *\n *\n * 特性：\n * - 可以指定条件条件表达式的间的逻辑关系：与、或、非；\n * - 条件表达式可以任意层级嵌套，即：条件集 可以 嵌套 条件集；\n * - 短路运算\n *    在对条件表达式进行运算的过程中，如果运算中途已经能够确认最终的运算结果，则便会停止对剩余表达式的计算，并返回计算结果；\n *\n * - 简单优先\n *    为了提高运算效率，除了加入了短路运算的特性外，还加入了简单优先的计算原则，即：对于同一层级表达式，会按照下面的顺序优先计算：\n *    1. BaseCondition | FunCondition: 除了 异步条件 PromCondition、条件集 ConditionSet 以外的所有其它数据类型的条件表达式，这些条件会被当作布尔值来计算；\n *    2. ConditionSet : 条件集；\n *    3. PromCondition : 异步条件；\n */\nexport function conditionOperat<ThisValue,Args>(condExpress:CondExpression<ThisValue,Args>,thisValue?:ThisValue, args?:Args):OperatedResult {\n\n  if (isBoolCondition(condExpress)){\n    return !!condExpress\n  }\n\n  if (isConditionSet(condExpress)){\n    var condSet:ConditionSet<ThisValue,Args> = condExpress as ConditionSet<ThisValue,Args>\n  }else {\n    condSet = [condExpress]\n  }\n\n  let notSequ = [condSet.not];\n  let notOper = function(b:boolean){\n    return notOperat(b,notSequ)\n  };\n\n  let proCondArr:PromCondition<ThisValue,Args>[] = []\n  let condSetArr:ConditionSet<ThisValue,Args> = []\n\n  if (condSet.rel === \"or\"){\n\n    //先对计算 不是 数组 和 不是 Promise 的 条件进行计算\n    let orRes = condSet.some(function (condExp) {\n\n      condExp = flatFunCondition(condExp,thisValue,args)\n\n      if (isBoolCondition(condExp)){\n        return condExp as boolean\n      }\n\n      //先跳过数组类型\n      if (isConditionSet(condExp)){\n        condSetArr.push(condExp)\n        return false\n      }\n\n\n      //先跳过 Promise 类型\n      if (isPromCondition(condExp)){\n        proCondArr.push(condExp)\n        return false\n      }\n\n      return notOperat(condExp,[condExp.not])\n    });\n\n    if (orRes){\n      return notOper(true)\n    }\n\n  //  专门 计算 数组条件的 运算结果\n  if (condSetArr.length > 0){\n    let condSetArrRes = condSetArr.some(function (condSet) {\n      let cond = conditionOperat(condSet);\n\n      //先跳过 Promise 类型\n      if (isPromCondition(cond)){\n        proCondArr.push(cond)\n        return false\n      }\n\n      return cond as boolean\n    });\n    if (condSetArrRes) {\n      return notOper(true)\n    }\n  }\n\n    //  专门 计算 Promise 条件的 运算结果\n  if (proCondArr.length > 0){\n    // @ts-ignore\n    return  Promise.allSettled(proCondArr).then(function (proCondArrResArr:{status:\"fulfilled\"|\"rejected\",value:CondExpression<ThisValue,Args>}[]) {\n      let proCondResArr:ConditionSet<ThisValue,Args> =  proCondArrResArr.map(function (proRes) {\n        if (proRes.status === \"fulfilled\"){\n          return proRes.value\n        }else {\n          return false\n        }\n      });\n\n      proCondResArr.rel = condSet.rel;\n      proCondResArr.not = condSet.not;\n      return conditionOperat(proCondResArr);\n    });\n\n  }\n\n  return notOper(orRes) ;\n\n\n\n\n  }else {\n\n\n\n    //先对计算 不是 数组 和 不是 Promise 的 条件进行计算\n    let andRes = condSet.every(function (condExp) {\n      condExp = flatFunCondition(condExp,thisValue,args)\n\n      if (isBoolCondition(condExp)){\n        return condExp as boolean\n      }\n\n      //先跳过数组类型\n      if (isConditionSet(condExp)){\n        condSetArr.push(condExp)\n        return true\n      }\n\n\n      //先跳过 Promise 类型\n      if (isPromCondition(condExp)){\n        proCondArr.push(condExp)\n        return true\n      }\n\n      return notOperat(condExp,[condExp.not])\n    });\n\n    if (!andRes){\n      return notOper(false)\n    }\n\n    //  专门 计算 数组条件的 运算结果\n    if (condSetArr.length > 0){\n      let condSetArrRes = condSetArr.every(function (condSet) {\n        let cond = conditionOperat(condSet);\n\n        //先跳过 Promise 类型\n        if (isPromCondition(cond)){\n          proCondArr.push(cond)\n          return true\n        }\n\n        return cond as boolean\n      });\n      if (!condSetArrRes) {\n        return notOper(false)\n      }\n    }\n\n    //  专门 计算 Promise 条件的 运算结果\n    if (proCondArr.length > 0){\n      // @ts-ignore\n      return  Promise.allSettled(proCondArr).then(function (proCondArrResArr:{status:\"fulfilled\"|\"rejected\",value:CondExpression<ThisValue,Args>}[]) {\n        let proCondResArr:ConditionSet<ThisValue,Args> =  proCondArrResArr.map(function (proRes) {\n          if (proRes.status === \"fulfilled\"){\n            return proRes.value\n          }else {\n            return false\n          }\n        });\n\n        proCondResArr.rel = condSet.rel;\n        proCondResArr.not = condSet.not;\n        return conditionOperat(proCondResArr);\n      });\n\n    }\n\n    return notOper(andRes);\n\n\n\n  }\n\n\n\n\n}\n\n\n/**\n * 创建快捷运算函数时的配置选项对象；\n */\ninterface CreateOptions<ThisValue,Args> {\n  expr?:CondExpression<ThisValue,Args>,   //条件表达式\n  this?:ThisValue,    //设置条件表达式中 函数条件 的 this 的值\n  args?:Args    //设置条件表达式中 函数条件 的 参数序列；即该参数是个数组，里面包含传递给 条件函数 的参数\n}\n\nfunction isCreateOptions(opts:any): opts is CreateOptions<any,any> {\n  return opts && (opts.expr || opts.this || opts.args)\n}\n\n\n/**\n * 创建快捷运算函数\n * 快捷运算函数 是带有一部分参数值，只接收剩余参数 的条件运算函数；\n *\n * 创建指定条件表达式的快捷运算函数\n */\n\n/**\n * create<ThisValue,Args>(expr:CondExpression<ThisValue,Args>): (thisValue?:ThisValue, args?:Args)=>OperatedResult\n *\n * @param expr:CondExpression<ThisValue,Args>   条件表达式\n * @return `(thisValue?:ThisValue, args?:Args)=>OperatedResult`  返回一个函数，该函数可接收 thisValue 和 args 两个参数；\n * \n */\nexport function create<ThisValue,Args>(expr:CondExpression<ThisValue,Args>): (thisValue?:ThisValue, args?:Args)=>OperatedResult;\n\n/**\n * create(options:CreateOptions<any,any>): (...rest: any[])=>OperatedResult\n * \n * @param options:CreateOptions<any,any>   创建选项对象\n * @return `(...rest: any[])=>OperatedResult`  返回一个函数，该函数可接收 选项对象 options 中没有提供的剩余参数，剩余的参数按照 `expr、this、args` 顺序（即 条件运算函数 `conditionOperat()` 的参数顺序）进行排列；\n * \n */\nexport function create(options:CreateOptions<any,any>): (...rest: any[])=>OperatedResult;\nexport function create<ThisValue,Args>(exprOrOpts: CondExpression<ThisValue,Args>|CreateOptions<ThisValue,Args>){\n\n  if (isCreateOptions(exprOrOpts)){\n    var {expr,\"this\":thisValue,args} = exprOrOpts\n  }else {\n    expr = exprOrOpts\n  }\n\n  let argArr = [expr,thisValue,args];\n\n  function operatWith(...rest: any[]):OperatedResult {\n    var finalArgArr = argArr.map(function (argItem) {\n      if (argItem === undefined) {\n        return rest.shift()\n      }\n\n      return argItem\n    });\n\n\n    return  conditionOperat(...finalArgArr as [CondExpression<ThisValue,Args>, ThisValue, Args] );\n  }\n\n\n\n  return operatWith;\n}\n\n\nconditionOperat.create = create;\n\n\nexport default conditionOperat\n"],"sourceRoot":""}