{"version":3,"sources":["webpack://conditionOperat/webpack/universalModuleDefinition","webpack://conditionOperat/webpack/bootstrap","webpack://conditionOperat/./src/conditionOperat.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","isObject","target","tarType","isMapCondition","cond","condType","String","Number","isPromCondition","Promise","isFunCondition","isConditionSet","expr","Array","isArray","notOperat","notSequ","reduce","res","not","valueOf","Boolean","flatCondition","operatOptions","thisValue","args","condMap","isNotExpression","nextExpr","apply","exprOpts","undefined","concat","isOperatOptions","opts","full","isExpressionOptions","conditionOperat","exprOrOptions","finalOperOpts","assign","conditionOperatForFull","conditionOperatForFast","condExpress","then","reason","condSet","notOper","b","proCondArr","condSetArr","rel","orRes","some","condExp","finalExpr","push","length","allSettled","proCondArrResArr","proCondResArr","map","proRes","status","andRes","every","condSetRes","operatWith","operOpts"],"mappings":"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","file":"conditionOperat.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"conditionOperat\"] = factory();\n\telse\n\t\troot[\"conditionOperat\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * conditionOperat 可以对一系列复杂的条件进行逻辑运算，条件可以是基本类型的数据，也可以是个函数，甚至可以是个异步条件，即 Promise；或者是个条件集，条件集也可以再嵌套条件集；可以指定条件之间的逻辑关系，如：与、或、非；\n *\n * - 主页：<https://github.com/GuoBinyong/condition-operat>\n *\n * **如果您在使用的过程中遇到了问题，或者有好的建议和想法，您都可以通过以下方式联系我，期待与您的交流：**\n * - 给该仓库提交 issues\n * - 给我 Pull requests\n * - 邮箱：<guobinyong@qq.com>\n * - QQ：guobinyong@qq.com\n * - 微信：keyanzhe\n */\n\n\n\n\n\n\n\n\n/**\n * 判断目标是否是对象类型\n * @param target : any   目标对象\n *\n * 仅通过 target instanceof Object 判断是不行的，因为 对于 Object.create(null) 创建的对象 通过 ` Object.create(null) instanceof Object ` 来判断 返回的是 false\n * 即：通过 Object.create(null) 创建的对象是不被 instanceof  认为是继续于 Object 的\n *\n * typeof null 也返回 \"object\"\n */\nfunction isObject(target:any):boolean {\n  // return target instanceof Object || typeof target === \"object\"\n  var tarType = typeof target;\n  return  target && (tarType === \"object\" || tarType === \"function\");\n}\n\n\n\n\n\n\n/**\n * 非运算表达式\n */\ninterface NotExpression {\n  /**\n   * 对原来的值取反\n   */\n  not?:boolean;\n}\n\n\n/**\n * NotExpression 的类型守卫\n */\nfunction isNotExpression(expr:any): expr is NotExpression {\n  return isObject(expr)\n}\n\n\n/**\n * 映射条件类型\n * 表示 在 条件映射对象 ConditionMap 中，条件表达式对应的 key\n */\ntype MapCondition = string | number | (String & NotExpression) | (Number & NotExpression) | symbol\n\n/**\n * MapCondition 的类型守卫\n */\nfunction isMapCondition(cond:any):  cond is  MapCondition {\n  let condType = typeof cond;\n  return condType === \"string\" || condType === \"number\" || condType === \"symbol\" || cond instanceof String || cond instanceof Number\n}\n\n\n/**\n * ConditionMap 的 属性类型\n */\ntype  ConditionMapKey = string | number\n\n/**\n * 条件映射对象的类型\n * 映射条件 可通过 该类型的对象来查找其对应的条件；\n *\n * 接口的索引签名类型不能用联合类型\n */\n/*interface ConditionMap<ThisValue, Args>  {\n  [prop : string | number | symbol]: CondExpression<ThisValue, Args>;\n}*/\ntype ConditionMap<ThisValue, Args> = {\n  [prop in ConditionMapKey ]: CondExpression<ThisValue, Args>;\n} & ThisType<ThisValue>;\n\n\n/**\n * ConditionMap 的类型守卫\n */\nfunction isConditionMap<ThisValue,Args>(condMap:any): condMap is ConditionMap<ThisValue,Args> {\n  return isObject(condMap)\n}\n\n\n\n\n\n\n/**\n * 对象条件类型\n * 表示那些除  函数条件 FunCondition 、异步条件 PromCondition 外 的 对象；当这些对象被作为 条件 时，会将其valueOf()方法返回的值转换成 布尔值，然后作 布尔条件 来用\n */\ninterface ObjCondition extends NotExpression{}\n\n/**\n * ObjCondition 的类型守卫\n */\nfunction isObjCondition(cond:any): cond is ObjCondition {\n  return cond && cond instanceof Object && !(isConditionSet(cond) || isFunCondition(cond) || isPromCondition(cond))\n}\n\n\n\n\n/**\n * 布尔条件\n * 代表那些可直接被当作布尔值来计算的 真假 和 假值；\n */\ntype BoolCondition = boolean | undefined | null | Boolean | ObjCondition\n\n\n\n/**\n * BoolCondition 的类型守卫\n */\nfunction isBoolCondition(cond:any): cond is BoolCondition {\n  return typeof cond === \"boolean\" || cond == undefined || cond instanceof Boolean || isObjCondition(cond)\n}\n\n\n/**\n * PromCondition 类型的条件返回的结果的类型\n */\ntype PromConditionResult<ThisValue,Args> =  BoolCondition | FunCondition<ThisValue,Args> | MapCondition | ConditionSet<ThisValue,Args>\n\n/**\n * 异步条件\n * 根据决议的值反复地进行条件运算，直到计算到得到 布尔结果 为止；\n */\n// interface PromCondition<ThisValue,Args> extends Promise<PromConditionResult<ThisValue,Args>>,NotExpression {}\ntype PromCondition<ThisValue,Args> = Promise<PromConditionResult<ThisValue,Args>> & NotExpression\n\n\n\n/**\n * PromCondition 的类型守卫\n */\nfunction isPromCondition<ThisValue,Args>(cond:any): cond is PromCondition<ThisValue,Args> {\n  return cond instanceof Promise\n}\n\n\n\n/**\n * 函数条件\n * 带有逻辑的函数，会对其返回值反复地进行条件运算，直到计算到得到 布尔结果 为止；\n */\ninterface FunCondition<ThisValue,Args> extends NotExpression {\n  (this:ThisValue,...args:Args extends any[] ? Args : []):CondExpression<ThisValue,Args>;\n}\n\n\n\n/**\n * FunCondition 的类型守卫\n */\nfunction isFunCondition<ThisValue,Args>(cond:any): cond is FunCondition<ThisValue,Args> {\n  return typeof cond === \"function\"\n}\n\n\n\n\n/**\n * 条件的类型\n * 条件是用来表达 真 或 假 的基本运算单元；\n */\ntype Condition<ThisValue,Args> = BoolCondition | FunCondition<ThisValue,Args> | PromCondition<ThisValue,Args> | MapCondition\n\n/**\n * Condition 的类型守卫\n */\nfunction isCondition<ThisValue,Args>(cond:any): cond is Condition<ThisValue,Args> {\n  return isFunCondition<ThisValue,Args>(cond) || isPromCondition<ThisValue,Args>(cond) || isMapCondition(cond) || isBoolCondition(cond)\n}\n\n\n\n/**\n * 关系类型\n */\ntype Relationship = \"and\" | \"or\"\n\n\n/**\n * 条件集\n * 条件集 ConditionSet 是用来表达 多个条件表达式 相与 或者 相或 关系的一种表达式；它包含多个条件表达式，并携带有关系信息（与、或）；\n */\ninterface ConditionSet<ThisValue,Args>  extends Array<CondExpression<ThisValue,Args>>,NotExpression {\n  /**\n   * 各个条件表达式之间的关系；\n   * 默认值：\"and\"\n   */\n  rel?:Relationship;\n}\n\n\n/**\n * ConditionSet 的类型守卫\n */\nfunction isConditionSet<ThisValue,Args>(expr:any): expr is ConditionSet<ThisValue,Args> {\n  return Array.isArray(expr)\n}\n\n\n\n\n/**\n * 条件表达式\n * 条件集 ConditionSet 和 条件 Condition 统称为 条件表达式\n */\ntype CondExpression<ThisValue,Args> = ConditionSet<ThisValue,Args> | Condition<ThisValue,Args>\n\n\n/**\n * CondExpression 的类型守卫\n */\nfunction isCondExpression<ThisValue,Args>(expr:any): expr is CondExpression<ThisValue,Args> {\n  return isConditionSet<ThisValue,Args>(expr) || isCondition<ThisValue,Args>(expr)\n}\n\n\n\n\n\n\n\n\n\n/**\n * 非值的类型\n */\ntype NotValue = NotExpression[\"not\"]\n\n/**\n * 非值的序列\n */\ntype NotSequence = NotValue[]\n\n\n/**\n * 对 target 做一系列连续的 非操作，\n * @param target : any    操作的目标，如果 target 有 valueOf() 方法，会将 valueOf() 方法返回的值作为布尔值来对象，否则，会直接将 target 作为布尔值来对待\n * @param notSequ : NotSequence    指示非操作序列的数组\n * @return boolean     非操作后的结果\n */\nfunction notOperat(target:any,notSequ:NotSequence):boolean {\n  return notSequ.reduce(function (res,not) {\n    return not && not.valueOf() ? !res : res;\n  },Boolean(target && target.valueOf ? target.valueOf() : target) ) as boolean\n}\n\n\n/**\n * flatCondition 将表达式扁平化处理之后的结果类型\n */\ntype FlatResult<ThisValue,Args> = {\n  expr:Exclude<CondExpression<ThisValue,Args>, MapCondition | FunCondition<ThisValue,Args>>,\n  notSequ:NotSequence\n};\n\n\n/**\n * 递归条件\n * 表示 需要通过 运算才能得到真正的条件，并且运算后得到的条件 可能还是个 与原来相同类型的 条件\n *\n * 注意：\n * - 因为 异步条件 PromCondition 通过运算后返回的不会再是异步条件，所以 异步条件 PromCondition 不是递归条件；\n * - 但是 异步条件 PromCondition 通过运算后返回的条件 可能会是一个再次返回 异步条件的 条件；比如：异步条件 反应一个 函数条件，而该函数条件返回的又是一个异步条件；\n */\ntype RecursiveCondition<ThisValue,Args> = MapCondition | FunCondition<ThisValue,Args>\n\n\n/**\n * 扁平化 递归条件 RecursiveCondition\n * @param operatOptions : OperatOptions   运算选项类型\n *\n * 函数条件 FunCondition 可能还会返回 函数条件 FunCondition，返回的 函数条件 FunCondition 可能还会返回 函数条件 FunCondition，可以无休止地这样延续下去；映射条件 MapCondition 也是；像这样的条件称为 递归条件\n * 本方法的作用就是对递归条件进行运算，直到返回的不是递归条件为止\n */\nfunction flatCondition<ThisValue,Args>(operatOptions:OperatOptions<ThisValue,Args>): FlatResult<ThisValue,Args> {\n\n  let {expr,\"this\":thisValue,args,notSequ,...otherProp} = operatOptions;\n  let condMap = otherProp as ConditionMap<ThisValue,Args>\n\n  if (!notSequ){\n    notSequ = isNotExpression(expr) ? [expr.not] : [];\n  }\n\n  if (isMapCondition(expr)){\n    var mapKey = (isObject(expr) ? expr.valueOf() : expr) as ConditionMapKey\n    var nextExpr = condMap[mapKey]\n  }else if (isFunCondition(expr)){\n    // @ts-ignore\n    nextExpr = expr.apply(thisValue,args)\n  }else {\n    return {\n      expr:expr,\n      notSequ:notSequ\n    };\n  }\n\n\n  let nextOperOpts = {...operatOptions,expr:nextExpr,notSequ:undefined};\n\n  var exprOpts = flatCondition(nextOperOpts);\n  exprOpts.notSequ = notSequ.concat(exprOpts.notSequ)\n\n  return exprOpts;\n}\n\n\n\n\n\n\n\n\n\n\n/**\n * 条件选项类型\n */\ninterface ExpressionOptions<ThisValue,Args> {\n  expr?:CondExpression<ThisValue,Args>,   //条件表达式\n  this?:ThisValue,    //设置条件表达式中 函数条件 的 this 的值\n\n  /**\n   * 设置条件表达式中 函数条件 的 参数序列；即该参数是个数组，里面包含传递给 条件函数 的参数\n   *\n   * 注意：\n   * thisValue 和 args 会被应用到所有的 函数条件，包括那些 运算过程 中产生的函数条件，比如：函数条件返回的函数条件、异步条件决议时传递出的 函数条件\n   */\n  args?:Args,\n\n  /**\n   * 是否要对表达式进行全量运算，默认是短路计算；全量计算会对条件集中的每个条件进行计算；\n   *\n   * # 全景运算\n   * 会对表达式中的所有条件依次且完全地进行运算\n   *\n   * # 短路运算\n   * 在对条件表达式进行运算的过程中，如果运算中途已经能够确认最终的运算结果，则便会停止对剩余表达式的计算，并返回计算结果；\n   *\n   * ## 简单优先\n   * 为了提高运算效率，除了加入了短路运算的特性外，还加入了简单优先的计算原则，即：对于同一层级表达式，会按照下面的顺序优先计算：\n   * 1. BoolCondition | RecursiveCondition: 布尔条件 BoolCondition 和 扁平化后 布尔条件 BoolCondition 的 递归条件 RecursiveCondition；\n   * 2. ConditionSet : 条件集；\n   * 3. PromCondition : 异步条件；\n   */\n  full?:boolean,\n\n  /*\n  非值的序列\n  如果存在该属性值，则忽略 expr 属性的 表达式的 not 属性\n  */\n notSequ?:NotSequence\n}\n\n/**\n * ExpressionOptions 的类型守卫\n */\nfunction isExpressionOptions<ThisValue,Args>(opts:any): opts is ExpressionOptions<ThisValue,Args> {\n  return opts && (opts.expr || opts.this || opts.args || opts.full || opts.notSequ)\n}\n\n\n\n\n\n\n\n\n\n/**\n * 条件运算的选项的类型\n */\ntype OperatOptions<ThisValue,Args> = ExpressionOptions<ThisValue,Args> & ConditionMap<ThisValue, Args>\n\n/**\n * OperatOptions 的类型守卫\n */\nfunction isOperatOptions<ThisValue,Args>(opts:any): opts is OperatOptions<ThisValue,Args> {\n  return isConditionMap<ThisValue,Args>(opts) || isExpressionOptions<ThisValue,Args>(opts)\n}\n\n\n\n\n\n\n\n/**\n * 运算结果的类型\n */\ntype OperatedResult = boolean | Promise<boolean>\n\n\n/**\n * conditionOperat 接口\n */\nexport interface conditionOperat {\n  create<ThisValue,Args>(...operatOptions:OperatOptions<ThisValue,Args>[]): (...operatOptions:OperatOptions<ThisValue,Args>[])=>OperatedResult;\n  create<ThisValue,Args>(condExpress:CondExpression<ThisValue,Args>,...operatOptions:OperatOptions<ThisValue,Args>[]): (...operatOptions:OperatOptions<ThisValue,Args>[])=>OperatedResult;\n}\n\n\n\n\n\n/**\n * 条件运算\n * 对一系列条件进行逻辑运算；\n *\n * @returns OperatedResult   返回 OperatedResult 类型的结果，即 布尔类型 或者 返回布尔类型的 Promise 类型 的值；\n * 只有依靠 异步条件 才能决定最后的运算结果时，conditionOperat 才会返回 Promise 类型的 异步运算结果\n */\n\n\n /**\n  * 接口1\n  * conditionOperat<ThisValue,Args>(...operatOptions:OperatOptions<ThisValue,Args>[]):OperatedResult\n  * @param operatOptions : OperatOptions  conditionOperat 接收一系列关于条件的选项对象\n  *\n  */\nexport function conditionOperat<ThisValue,Args>(...operatOptions:OperatOptions<ThisValue,Args>[]):OperatedResult;\n\n/**\n * 接口2\n * @param condExpress : CondExpression   条件表达式\n * @param operatOptions : OperatOptions   一系列关于条件的选项对象\n *\n */\nexport function conditionOperat<ThisValue,Args>(condExpress:CondExpression<ThisValue,Args>,...operatOptions:OperatOptions<ThisValue,Args>[]):OperatedResult;\nexport function conditionOperat<ThisValue,Args>(exprOrOptions:CondExpression<ThisValue,Args>|OperatOptions<ThisValue,Args>,...operatOptions:OperatOptions<ThisValue,Args>[]):OperatedResult {\n\n  let finalOperOpts = Object.assign({},exprOrOptions,...operatOptions);\n\n  /*\n  在以下任一情况下，都需要将 exprOrOptions 作为 表达式来用\n  - finalOperOpts 中没有表达式 expr 属性；\n  - exprOrOptions 不是 OperatOptions 类型；\n  */\n  if (!( \"expr\" in finalOperOpts && isOperatOptions(exprOrOptions))){\n    finalOperOpts.expr = exprOrOptions;\n  }\n\n  if (finalOperOpts.full){\n    return conditionOperatForFull(finalOperOpts);\n  }\n\n  return conditionOperatForFast(finalOperOpts);\n}\n\n\n /**\n  * 以短路的方式进行条件运算\n  * conditionOperatForFast<ThisValue,Args>(operatOptions:OperatOptions<ThisValue,Args>):OperatedResult\n  * @param operatOptions : OperatOptions  关于条件的选项对象\n  *\n  * @returns OperatedResult   返回 OperatedResult 类型的结果，即 布尔类型 或者 返回布尔类型的 Promise 类型 的值；\n  * 只有依靠 异步条件 才能决定最后的运算结果时，conditionOperat 才会返回 Promise 类型的 异步运算结果\n  */\nfunction conditionOperatForFast<ThisValue,Args>(operatOptions:OperatOptions<ThisValue,Args>):OperatedResult {\n\n  let finalOperOpts = {...operatOptions};\n\n  let {\"this\":thisValue,args,...condMap} = finalOperOpts;\n\n  let {expr:condExpress,notSequ} = flatCondition(finalOperOpts);\n\n  if (isPromCondition<ThisValue,Args>(condExpress)){\n    return condExpress.then(function(expr){\n      finalOperOpts.expr = expr;\n      finalOperOpts.notSequ = notSequ;\n      return conditionOperatForFast(finalOperOpts);\n    },function(reason){\n      return notOperat(false,notSequ);\n    });\n  } else if (isConditionSet(condExpress)){\n    var condSet:ConditionSet<ThisValue,Args> = condExpress as ConditionSet<ThisValue,Args>\n  } else {\n    return notOperat(condExpress,notSequ);\n  }\n\n\n\n\n  let notOper = function(b:any){\n    return notOperat(b,notSequ)\n  };\n\n  let proCondArr:PromCondition<ThisValue,Args>[] = []\n  let condSetArr:ConditionSet<ThisValue,Args> = []\n\n  if (condSet.rel === \"or\"){\n\n    //先计算 不是 数组 和 不是 Promise 的 条件进行计算\n    let orRes = condSet.some(function (condExp) {\n\n      let operOpts = {...finalOperOpts,expr:condExp,notSequ:undefined};\n\n      let {expr:finalExpr,notSequ} = flatCondition(operOpts);\n\n      if (isConditionSet(finalExpr)){\n        condSetArr.push(finalExpr)\n        return false\n      }else if (isPromCondition<ThisValue,Args>(finalExpr)) {\n        proCondArr.push(finalExpr)\n        return false\n      }else {\n        return notOperat(finalExpr,notSequ);\n      }\n\n\n    });\n\n    if (orRes){\n      return notOper(true)\n    }\n\n  //  专门 计算 数组条件的 运算结果\n  if (condSetArr.length > 0){\n    let condSetArrRes = condSetArr.some(function (condSet) {\n      let operOpts = {...finalOperOpts,expr:condSet,notSequ:undefined};\n      let cond = conditionOperatForFast(operOpts);\n\n      //先跳过 Promise 类型\n      if (isPromCondition(cond)){\n        proCondArr.push(cond)\n        return false\n      }\n\n      return cond;\n    });\n    if (condSetArrRes) {\n      return notOper(true)\n    }\n  }\n\n    //  专门 计算 Promise 条件的 运算结果\n  if (proCondArr.length > 0){\n    return  Promise.allSettled(proCondArr).then(function (proCondArrResArr) {\n      let proCondResArr:ConditionSet<ThisValue,Args> =  proCondArrResArr.map(function (proRes) {\n        return proRes.status === \"fulfilled\" ? proRes.value : false\n      });\n\n      proCondResArr.rel = condSet.rel;\n      let operOpts = {...finalOperOpts,expr:proCondResArr,notSequ};\n      return conditionOperatForFast(operOpts);\n    });\n\n  }\n\n  return notOper(orRes) ;\n\n\n\n\n  }else {\n\n\n\n    //先计算 不是 数组 和 不是 Promise 的 条件进行计算\n    let andRes = condSet.every(function (condExp) {\n\n      let operOpts = {...finalOperOpts,expr:condExp,notSequ:undefined};\n\n      let {expr:finalExpr,notSequ} = flatCondition(operOpts);\n\n\n      if (isConditionSet(finalExpr)){\n        condSetArr.push(finalExpr)\n        return true\n      }else if(isPromCondition<ThisValue,Args>(finalExpr)){\n        proCondArr.push(finalExpr)\n        return true\n      }else {\n        return notOperat(finalExpr,notSequ);\n      }\n\n    });\n\n    if (!andRes){\n      return notOper(false)\n    }\n\n    //  专门 计算 数组条件的 运算结果\n    if (condSetArr.length > 0){\n      let condSetArrRes = condSetArr.every(function (condSet) {\n        let operOpts = {...finalOperOpts,expr:condSet,notSequ:undefined};\n        let cond = conditionOperatForFast(operOpts);\n\n\n        //先跳过 Promise 类型\n        if (isPromCondition(cond)){\n          proCondArr.push(cond)\n          return true\n        }\n\n        return cond\n      });\n      if (!condSetArrRes) {\n        return notOper(false)\n      }\n    }\n\n    //  专门 计算 Promise 条件的 运算结果\n    if (proCondArr.length > 0){\n      return  Promise.allSettled(proCondArr).then(function (proCondArrResArr) {\n        let proCondResArr:ConditionSet<ThisValue,Args> =  proCondArrResArr.map(function (proRes) {\n          return proRes.status === \"fulfilled\" ? proRes.value : false\n        });\n\n        proCondResArr.rel = condSet.rel;\n\n        let operOpts = {...finalOperOpts,expr:proCondResArr,notSequ};\n        return conditionOperatForFast(operOpts);\n      });\n\n    }\n\n    return notOper(andRes);\n\n\n\n  }\n\n\n\n\n}\n\n\n\n\n\n /**\n  * 以全量的方式进行条件运算\n  * conditionOperatForFull<ThisValue,Args>(operatOptions:OperatOptions<ThisValue,Args>):OperatedResult\n  * @param operatOptions : OperatOptions  关于条件的选项对象\n  *\n  * @returns OperatedResult   返回 OperatedResult 类型的结果，即 布尔类型 或者 返回布尔类型的 Promise 类型 的值；\n  * 只有依靠 异步条件 才能决定最后的运算结果时，conditionOperat 才会返回 Promise 类型的 异步运算结果\n  */\nfunction conditionOperatForFull<ThisValue,Args>(operatOptions:OperatOptions<ThisValue,Args>):OperatedResult {\n\n  let finalOperOpts = {...operatOptions};\n\n  let {\"this\":thisValue,args,...condMap} = finalOperOpts;\n\n  let {expr:condExpress,notSequ} = flatCondition(finalOperOpts);\n\n\n  if (isPromCondition<ThisValue,Args>(condExpress)){\n    return condExpress.then(function(expr){\n      finalOperOpts.expr = expr;\n      finalOperOpts.notSequ = notSequ;\n      return conditionOperatForFull(finalOperOpts);\n    },function(reason){\n      return notOperat(false,notSequ);\n    });\n  } else if (isConditionSet(condExpress)){\n    var condSet:ConditionSet<ThisValue,Args> = condExpress as ConditionSet<ThisValue,Args>\n    var condSetRes = condSet.map(function (condExp) {\n      let operOpts = {...finalOperOpts,expr:condExp,notSequ:undefined};\n      return conditionOperatForFull(operOpts);\n    });\n  } else {\n    return notOperat(condExpress,notSequ);\n  }\n\n\n  let notOper = function(b:any){\n    return notOperat(b,notSequ)\n  };\n\n  let proCondArr:PromCondition<ThisValue,Args>[] = []\n\n  if (condSet.rel === \"or\"){\n\n    //通过 不是 Promise 的 结果来确定 condSet 的值\n    let orRes = condSetRes.some(function (condExp) {\n\n      if (condExp instanceof Promise){\n        proCondArr.push(condExp)\n        return false\n      }\n\n      return condExp;\n    });\n\n    if (orRes){\n      return notOper(true)\n    }\n\n  //通过 Promise 的 结果来确定 condSet 的值\n  if (proCondArr.length > 0){\n    return  Promise.allSettled(proCondArr).then(function (proCondArrResArr) {\n      let proCondResArr:ConditionSet<ThisValue,Args> =  proCondArrResArr.map(function (proRes) {\n        return proRes.status === \"fulfilled\" ? proRes.value : false\n      });\n\n      proCondResArr.rel = condSet.rel;\n      let operOpts = {...finalOperOpts,expr:proCondResArr,notSequ};\n      return conditionOperatForFull(operOpts);\n    });\n\n  }\n\n  return notOper(orRes) ;\n\n\n\n\n  }else {\n\n\n\n    //通过 不是 Promise 的 结果来确定 condSet 的值\n    let andRes = condSetRes.every(function (condExp) {\n      if (condExp instanceof Promise){\n        proCondArr.push(condExp)\n        return true\n      }\n\n      return condExp;\n    });\n\n    if (!andRes){\n      return notOper(false)\n    }\n\n    //通过 Promise 的 结果来确定 condSet 的值\n    if (proCondArr.length > 0){\n      return  Promise.allSettled(proCondArr).then(function (proCondArrResArr) {\n        let proCondResArr:ConditionSet<ThisValue,Args> =  proCondArrResArr.map(function (proRes) {\n          return proRes.status === \"fulfilled\" ? proRes.value : false\n        });\n\n        proCondResArr.rel = condSet.rel;\n\n        let operOpts = {...finalOperOpts,expr:proCondResArr,notSequ};\n        return conditionOperatForFull(operOpts);\n      });\n\n    }\n\n    return notOper(andRes);\n\n\n\n  }\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 创建快捷运算函数\n * 快捷运算函数 是带有默认选项的条件运算函数；\n */\n\n  /**\n  * 接口1\n  * create<ThisValue,Args>(...operatOptions:OperatOptions<ThisValue,Args>[]): (...operatOptions:OperatOptions<ThisValue,Args>[])=>OperatedResult\n  * @param operatOptions : OperatOptions  conditionOperat 接收一系列关于条件的选项对象\n  */\nexport function create<ThisValue,Args>(...operatOptions:OperatOptions<ThisValue,Args>[]): (...operatOptions:OperatOptions<ThisValue,Args>[])=>OperatedResult;\n\n/**\n * 接口2\n * create<ThisValue,Args>(condExpress:CondExpression<ThisValue,Args>,...operatOptions:OperatOptions<ThisValue,Args>[]): (...operatOptions:OperatOptions<ThisValue,Args>[])=>OperatedResult\n * @param condExpress : CondExpression   条件表达式\n * @param operatOptions : OperatOptions   一系列关于条件的选项对象\n */\nexport function create<ThisValue,Args>(condExpress:CondExpression<ThisValue,Args>,...operatOptions:OperatOptions<ThisValue,Args>[]): (...operatOptions:OperatOptions<ThisValue,Args>[])=>OperatedResult;\nexport function create<ThisValue,Args>(exprOrOptions:CondExpression<ThisValue,Args>|OperatOptions<ThisValue,Args>,...operatOptions:OperatOptions<ThisValue,Args>[]){\n\n\n  var finalOperOpts = Object.assign({},exprOrOptions,...operatOptions);\n\n  if (!isOperatOptions(exprOrOptions)){\n    finalOperOpts.expr = exprOrOptions;\n  }\n\n  function operatWith(...operOpts:OperatOptions<ThisValue,Args>[]):OperatedResult {\n    return  conditionOperat(finalOperOpts,...operOpts);\n  }\n\n  return operatWith;\n}\n\n\nconditionOperat.create = create;\n\n\nexport default conditionOperat\n"],"sourceRoot":""}